<!DOCTYPE html>
<html>
<head>
<title>PDF Viewer</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    padding: 0;
    background-color: #f4f4f4;
    color: #333;
  }
  #toolbar {
    background-color: #333;
    padding: 10px;
    margin-bottom: 20px;
    text-align: center;
  }
  #toolbar button {
    background-color: #555;
    color: white;
    border: none;
    padding: 10px 15px;
    margin: 0 5px;
    cursor: pointer;
    border-radius: 5px;
  }
  #toolbar button:hover {
    background-color: #777;
  }
  #pdfViewer {
    border: 1px solid #ccc;
    height: 80vh; /* 80% of viewport height */
    width: 80%;
    margin: 0 auto; /* Center the viewer */
    background-color: #fff;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    position: relative; /* For absolute positioning of annotations */
  }
  .textAnnotation {
      position: absolute;
      background-color: rgba(255, 255, 0, 0.2); /* Light yellow background */
      border: 1px dashed #ccc;
      padding: 2px;
      font-size: 16px; /* Adjust as needed */
      resize: both; /* Allow resizing */
      overflow: hidden;
      min-width: 20px;
      min-height: 20px;
  }
  .textAnnotation:focus {
      border: 1px solid #007bff;
      outline: none;
  }
  .textAnnotation { /* Added cursor: move; */
      /* ... existing styles ... */
      cursor: move;
  }
  .comment-marker { /* 1. CSS for visual comment markers */
    position: absolute;
    width: 15px;
    height: 15px;
    background-color: #ff4500; /* Orangey-red */
    border-radius: 50%;
    box-shadow: 0 0 3px rgba(0,0,0,0.5);
    cursor: help; 
    /* pointer-events: none; was considered but class-based removal is better */
  }
  .annotation-selected { /* 1. CSS for selected text annotation */
    border: 2px solid blue !important; /* Use !important to override existing border */
  }
  .comment-marker.annotation-selected { /* 1. CSS for selected comment marker */
    box-shadow: 0 0 5px 3px blue !important; /* Use !important to override existing shadow */
  }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
<script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';
</script>
<script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
</head>
<body>

<input type="file" id="pdfFile" accept=".pdf">
<div id="toolbar">
  <button id="addTextButton">Add Text</button>
  <button id="addCommentButton">Add Comment</button>
  <button id="deleteAnnotationButton">Delete Selected</button> <!-- 2. Add Delete button -->
  <button id="savePdfButton">Save PDF</button>
</div>
<div id="pdfViewer"></div>

<script>
  const pdfFileElement = document.getElementById('pdfFile');
  const pdfViewerElement = document.getElementById('pdfViewer');
  const addTextButtonElement = document.getElementById('addTextButton');
  const PDF_JS_SCALE = 1.5; // Define the PDF.js render scale globally
  const addCommentButtonElement = document.getElementById('addCommentButton');
  const deleteAnnotationButtonElement = document.getElementById('deleteAnnotationButton'); // Get delete button
  const savePdfButtonElement = document.getElementById('savePdfButton');
  let isAddTextMode = false;
  let isAddCommentMode = false;
  let selectedAnnotationId = null; // 1. Global variable for selected annotation

  // CDN Library Check
  if (!window.pdfjsLib || !window.PDFLib) {
    alert("Error: A required library (PDF.js or pdf-lib.js) failed to load. Please check your internet connection or ad-blockers and try again.");
    if (pdfFileElement) pdfFileElement.disabled = true;
    if (addTextButtonElement) addTextButtonElement.disabled = true;
    if (addCommentButtonElement) addCommentButtonElement.disabled = true;
    if (deleteAnnotationButtonElement) deleteAnnotationButtonElement.disabled = true; // Disable delete button
    if (savePdfButtonElement) savePdfButtonElement.disabled = true;
  }

  // 3. Basic Initialization Snippet for pdf-lib
  const { PDFDocument, rgb, StandardFonts } = PDFLib; // Ensure PDFLib is available from window

  async function testPdfLib() {
    try {
      const pdfDoc = await PDFDocument.create();
      const page = pdfDoc.addPage();
      page.drawText('pdf-lib is loaded!', {
        x: 50,
        y: page.getHeight() - 50,
        font: await pdfDoc.embedFont(StandardFonts.Helvetica),
        size: 24,
        color: rgb(0, 0.53, 0.71),
      });
      console.log('pdf-lib successfully created a test PDF in memory.');
    } catch (e) {
      console.error('Error testing pdf-lib:', e);
      alert('Error initializing pdf-lib. Check console.');
    }
  }
  // testPdfLib(); // Call if you want to test on load

  let annotations = []; // Initialize Annotations Array
  let isDragging = false;
  let draggedElement = null;
  let offsetX = 0;
  let offsetY = 0;
  let currentDraggedAnnotationId = null; // This is for drag state, not selection state
  let originalPdfBytes = null;
  
  // Helper function to remove selection visuals
  function clearSelectionVisuals() {
    const previouslySelected = document.querySelector('.annotation-selected');
    if (previouslySelected) {
      previouslySelected.classList.remove('annotation-selected');
    }
  }

  // Helper function to set selection visuals
  function setSelectionVisuals(element) {
    if (element) {
      element.classList.add('annotation-selected');
    }
  }

  // Shared delete logic
  function deleteSelectedAnnotation() {
    if (!selectedAnnotationId) {
      alert("No annotation selected to delete.");
      return;
    }

    const annotationIndex = annotations.findIndex(anno => anno.id === selectedAnnotationId);
    if (annotationIndex === -1) {
      console.error("Selected annotation not found in array:", selectedAnnotationId);
      selectedAnnotationId = null; // Reset if data is inconsistent
      clearSelectionVisuals();
      return;
    }

    const annotationToDelete = annotations[annotationIndex];

    // Remove visual element
    const visualElement = document.querySelector(`[data-annotation-id="${selectedAnnotationId}"]`);
    if (visualElement) {
      visualElement.remove();
    } else {
      console.warn("Visual element for annotation not found:", selectedAnnotationId);
    }

    // Remove from annotations array
    annotations.splice(annotationIndex, 1);
    console.log("Annotation deleted:", annotationToDelete.id, "Remaining:", annotations);
    
    selectedAnnotationId = null;
    // Visuals already cleared by clearSelectionVisuals() if called before this or handled by new selection
  }


  addTextButtonElement.addEventListener('click', function() {
    isAddTextMode = !isAddTextMode;
    if (isAddTextMode) {
      addTextButtonElement.style.backgroundColor = '#007bff';
      addTextButtonElement.textContent = 'Cancel Add Text';
      pdfViewerElement.style.cursor = 'crosshair';
      // Ensure other modes are off
      isAddCommentMode = false;
      addCommentButtonElement.style.backgroundColor = '#555';
      addCommentButtonElement.textContent = 'Add Comment';
    } else {
      addTextButtonElement.style.backgroundColor = '#555';
      addTextButtonElement.textContent = 'Add Text';
      pdfViewerElement.style.cursor = 'default';
    }
  });

  // 2. Comment Mode Logic & Storage (Button Listener)
  addCommentButtonElement.addEventListener('click', function() {
    isAddCommentMode = !isAddCommentMode;
    if (isAddCommentMode) {
      addCommentButtonElement.style.backgroundColor = '#ffc107'; // Example: Yellow
      addCommentButtonElement.textContent = 'Cancel Add Comment';
      pdfViewerElement.style.cursor = 'help';
      // Ensure other modes are off
      isAddTextMode = false;
      addTextButtonElement.style.backgroundColor = '#555';
      addTextButtonElement.textContent = 'Add Text';
    } else {
      addCommentButtonElement.style.backgroundColor = '#555';
      addCommentButtonElement.textContent = 'Add Comment';
      pdfViewerElement.style.cursor = 'default';
    }
  });

  pdfViewerElement.addEventListener('click', function(event) {
    // Common logic for identifying clicked canvas and coordinates
    const clickedCanvas = event.target.tagName === 'CANVAS' ? event.target : null;
    if (!clickedCanvas) return; // Click was not on a canvas

    const allCanvases = Array.from(pdfViewerElement.getElementsByTagName('canvas'));
    const clickedPageIndex = allCanvases.indexOf(clickedCanvas);
    if (clickedPageIndex === -1) {
      console.error("Clicked canvas not found in pdfViewerElement.");
      return;
    }
    const canvasRect = clickedCanvas.getBoundingClientRect();
    const xPosOnCanvas = event.clientX - canvasRect.left;
    const yPosOnCanvas = event.clientY - canvasRect.top;
    const viewerRect = pdfViewerElement.getBoundingClientRect();
    const visualX = event.clientX - viewerRect.left + pdfViewerElement.scrollLeft;
    const visualY = event.clientY - viewerRect.top + pdfViewerElement.scrollTop;

    if (isAddTextMode) {
      // Existing Text Annotation Logic (ensure it uses the common variables above)
      const newAnnotationId = `anno_${Date.now()}`;
      const newAnnotationData = {
        id: newAnnotationId, pageNum: clickedPageIndex + 1, 
        x: xPosOnCanvas / PDF_JS_SCALE, // Normalize x
        y: yPosOnCanvas / PDF_JS_SCALE, // Normalize y
        text: '', width: 150 / PDF_JS_SCALE, height: 50 / PDF_JS_SCALE, // Normalize width/height if they are visual
        type: 'text'
      };
      annotations.push(newAnnotationData);
      const textAnnotationElement = document.createElement('textarea');
      textAnnotationElement.className = 'textAnnotation';
      textAnnotationElement.dataset.annotationId = newAnnotationId;
      textAnnotationElement.style.left = visualX + 'px';
      textAnnotationElement.style.top = visualY + 'px';
      // Visual width/height remain as they were, based on initial pixel values for display
      textAnnotationElement.style.width = (newAnnotationData.width * PDF_JS_SCALE) + 'px'; 
      textAnnotationElement.style.height = (newAnnotationData.height * PDF_JS_SCALE) + 'px';
      textAnnotationElement.value = newAnnotationData.text;
      textAnnotationElement.addEventListener('input', function(e) {
        const currentId = e.target.dataset.annotationId;
        const annotationToUpdate = annotations.find(anno => anno.id === currentId);
        if (annotationToUpdate) annotationToUpdate.text = e.target.value;
      });
      textAnnotationElement.addEventListener('mousedown', function(e) {
        // Dragging logic (existing)
        if (isAddTextMode || isAddCommentMode) return; // Don't drag if in add mode

        // If not starting a drag immediately, or if it's a simple click, handle selection
        // This logic might need refinement to distinguish click from drag start better.
        // For now, selection happens on mousedown before drag starts.
        
        clearSelectionVisuals();
        selectedAnnotationId = e.target.dataset.annotationId;
        setSelectionVisuals(e.target);
        console.log("Selected text annotation:", selectedAnnotationId);

        // Drag initiation (existing)
        // Only preventDefault if we are actually starting a drag, not just selecting.
        // However, the current structure initiates drag immediately on mousedown.
        e.preventDefault(); 
        draggedElement = e.target;
        currentDraggedAnnotationId = draggedElement.dataset.annotationId; // For drag
        isDragging = true;
        const rect = draggedElement.getBoundingClientRect();
        const viewerRectForDrag = pdfViewerElement.getBoundingClientRect();
        offsetX = e.clientX - (rect.left - viewerRectForDrag.left + pdfViewerElement.scrollLeft);
        offsetY = e.clientY - (rect.top - viewerRectForDrag.top + pdfViewerElement.scrollTop);
      });
      // Consider adding a separate 'click' listener for selection if mousedown is too complex.
      // textAnnotationElement.addEventListener('click', function(e){ ... selection logic ... });
      pdfViewerElement.appendChild(textAnnotationElement);
      textAnnotationElement.focus();
      isAddTextMode = false;
      addTextButtonElement.style.backgroundColor = '#555';
      addTextButtonElement.textContent = 'Add Text';
      pdfViewerElement.style.cursor = 'default';

    } else if (isAddCommentMode) { // 3. Placing Comment Markers & Inputting Text
      const commentText = prompt('Enter your comment:');
      if (commentText && commentText.trim() !== '') {
        const marker = document.createElement('div');
        const newCommentId = `comment_${Date.now()}`;
        marker.className = 'comment-marker';
        marker.dataset.annotationId = newCommentId; // 3. Store ID on marker
        marker.style.left = (visualX - 7.5) + 'px'; 
        marker.style.top = (visualY - 7.5) + 'px';
        
        // 3. Click listener for comment marker selection
        marker.addEventListener('click', function(e) {
          e.stopPropagation(); // Prevent pdfViewer click
          if (isAddTextMode || isAddCommentMode) return;

          clearSelectionVisuals();
          selectedAnnotationId = e.target.dataset.annotationId;
          setSelectionVisuals(e.target);
          console.log("Selected comment annotation:", selectedAnnotationId);
        });
        
        pdfViewerElement.appendChild(marker);

        const newCommentAnnotation = {
          id: newCommentId, // Ensure ID is stored in annotation object
          type: 'comment',
          pageNum: clickedPageIndex + 1,
          x: xPosOnCanvas / PDF_JS_SCALE, // Normalize x
          y: yPosOnCanvas / PDF_JS_SCALE, // Normalize y
          text: commentText.trim(),
          // No need to store markerVisual, will be cleared by class
        };
        annotations.push(newCommentAnnotation);
        console.log("Comment annotation added:", newCommentAnnotation);
      }
      // Reset mode
      isAddCommentMode = false;
      addCommentButtonElement.style.backgroundColor = '#555';
      addCommentButtonElement.textContent = 'Add Comment';
      pdfViewerElement.style.cursor = 'default';
    }
  });

  // Global mousemove and mouseup listeners for dragging TEXT annotations
  document.addEventListener('mousemove', function(e) {
    if (!isDragging || !draggedElement || (draggedElement.tagName !== 'TEXTAREA')) return; // Only drag textareas
    
    const viewerRect = pdfViewerElement.getBoundingClientRect();
    let newVisualX = e.clientX - viewerRect.left - offsetX + pdfViewerElement.scrollLeft;
    let newVisualY = e.clientY - viewerRect.top - offsetY + pdfViewerElement.scrollTop;
    draggedElement.style.left = newVisualX + 'px';
    draggedElement.style.top = newVisualY + 'px';
  });

  document.addEventListener('mouseup', function(e) {
    if (!isDragging || !draggedElement || (draggedElement.tagName !== 'TEXTAREA')) { // Only drag textareas
        if(isDragging && !draggedElement) isDragging = false; // Reset if somehow only isDragging is true
        return;
    }
    
    const annotation = annotations.find(anno => anno.id === currentDraggedAnnotationId && anno.type === 'text');
    if (annotation) {
      const allCanvases = Array.from(pdfViewerElement.getElementsByTagName('canvas'));
      const targetCanvas = allCanvases[annotation.pageNum - 1];
      if (targetCanvas) {
        const canvasRect = targetCanvas.getBoundingClientRect();
        const viewerRectForDrag = pdfViewerElement.getBoundingClientRect();
        const canvasOffsetXInViewer = (canvasRect.left - viewerRectForDrag.left) + pdfViewerElement.scrollLeft;
        const canvasOffsetYInViewer = (canvasRect.top - viewerRectForDrag.top) + pdfViewerElement.scrollTop;
        // The style.left/top are visual, relative to scaled canvas.
        // Convert them to be relative to unscaled canvas for storage.
        const newUnscaledX = (parseFloat(draggedElement.style.left) - canvasOffsetXInViewer) / PDF_JS_SCALE;
        const newUnscaledY = (parseFloat(draggedElement.style.top) - canvasOffsetYInViewer) / PDF_JS_SCALE;
        
        annotation.x = newUnscaledX;
        annotation.y = newUnscaledY;
        // Note: width/height for text annotations are not updated on drag, only position.
      }
    }
    isDragging = false;
    draggedElement = null;
    currentDraggedAnnotationId = null; // This is for DRAG state, not selection
    offsetX = 0;
    offsetY = 0;
  });

  // 3. Deselecting on pdfViewer click
  pdfViewerElement.addEventListener('click', function(event) {
    // If the click is directly on pdfViewer (not on a canvas, textarea, or marker which have their own click handlers)
    // or if it's on a canvas but not in an "add" mode.
    if (event.target === pdfViewerElement || event.target.tagName === 'CANVAS') {
        if (!isAddTextMode && !isAddCommentMode) { // Don't deselect if an add mode is active
            clearSelectionVisuals();
            selectedAnnotationId = null;
            console.log("Deselected all.");
        }
    }
    // The specific logic for placing annotations (text/comment) is now inside the mode-specific blocks
    // within the main pdfViewerElement click listener defined earlier.
    // This listener is primarily for deselection.
  }, false); // Use capture phase false to ensure it runs after specific element clicks


  // 2. Delete Selected Button Listener
  deleteAnnotationButtonElement.addEventListener('click', deleteSelectedAnnotation);

  // 3. Delete Key Functionality
  document.addEventListener('keydown', function(event) {
    if ((event.key === 'Delete' || event.key === 'Backspace') && selectedAnnotationId) {
      // Prevent deletion if user is typing in a textarea or another input field
      const activeElement = document.activeElement;
      if (activeElement && (activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'INPUT') && activeElement !== document.body) {
        // If a text annotation is selected AND focused, allow delete key to work for text editing.
        // If it's selected but NOT focused, then delete the annotation.
        const selectedVisualElement = document.querySelector(`[data-annotation-id="${selectedAnnotationId}"]`);
        if (selectedVisualElement === activeElement) {
            return; 
        }
      }
      event.preventDefault(); // Prevent browser back navigation on Backspace
      deleteSelectedAnnotation();
    }
  });

  savePdfButtonElement.addEventListener('click', async function() {
    if (!originalPdfBytes) {
      alert("Please load a PDF file first.");
      const allCanvases = Array.from(pdfViewerElement.getElementsByTagName('canvas'));
      const clickedPageIndex = allCanvases.indexOf(clickedCanvas); // Zero-based

      if (clickedPageIndex === -1) {
        console.error("Clicked canvas not found in pdfViewerElement.");
        return;
      }

      // Calculate coordinates relative to the clicked canvas
      const canvasRect = clickedCanvas.getBoundingClientRect();
      const xPosOnCanvas = event.clientX - canvasRect.left;
      const yPosOnCanvas = event.clientY - canvasRect.top;

      // For visual positioning of the textarea: use coordinates relative to pdfViewerElement
      // This is similar to previous implementation for visual placement.
      const viewerRect = pdfViewerElement.getBoundingClientRect();
      const visualX = event.clientX - viewerRect.left + pdfViewerElement.scrollLeft;
      const visualY = event.clientY - viewerRect.top + pdfViewerElement.scrollTop;
      
      const newAnnotationId = `anno_${Date.now()}`;
      const newAnnotationData = {
        id: newAnnotationId,
        pageNum: clickedPageIndex + 1, // Store 1-based page number
        x: xPosOnCanvas,
        y: yPosOnCanvas,
        // Note: For true PDF point coordinates, these x/y might need division by page scale later.
        // For now, they are canvas-pixel-relative.
        text: '',
        width: 150, // Default width in pixels
        height: 50, // Default height in pixels
        type: 'text'
      };
      annotations.push(newAnnotationData);
      console.log("Annotation added:", newAnnotationData);
      console.log("All annotations:", annotations);


      const textAnnotationElement = document.createElement('textarea');
      textAnnotationElement.className = 'textAnnotation';
      textAnnotationElement.dataset.annotationId = newAnnotationId; // Assign ID
      textAnnotationElement.style.left = visualX + 'px';
      textAnnotationElement.style.top = visualY + 'px';
      textAnnotationElement.style.width = newAnnotationData.width + 'px';
      textAnnotationElement.style.height = newAnnotationData.height + 'px';
      textAnnotationElement.value = newAnnotationData.text; // Set initial text

      // 3. Update Annotation on Text Input
      textAnnotationElement.addEventListener('input', function(e) {
        const currentId = e.target.dataset.annotationId;
        const annotationToUpdate = annotations.find(anno => anno.id === currentId);
        if (annotationToUpdate) {
          annotationToUpdate.text = e.target.value;
          // console.log("Annotation updated:", annotationToUpdate);
          // console.log("All annotations:", annotations);
        }
      });
      
      // (Optional: ResizeObserver for width/height updates)
      // ... (ResizeObserver code from previous step, can be kept if desired) ...

      // Add mousedown listener for dragging
      textAnnotationElement.addEventListener('mousedown', function(e) {
        // Prevent conflict with adding new text if add text mode is somehow active
        if (isAddTextMode) {
            isAddTextMode = false;
            addTextButtonElement.style.backgroundColor = '#555';
            addTextButtonElement.textContent = 'Add Text';
            pdfViewerElement.style.cursor = 'default';
        }

        e.preventDefault(); // Prevent text selection/browser drag
        
        draggedElement = e.target;
        currentDraggedAnnotationId = draggedElement.dataset.annotationId;
        isDragging = true;

        // Calculate offset from mouse pointer to textarea's top-left corner
        const rect = draggedElement.getBoundingClientRect();
        const viewerRect = pdfViewerElement.getBoundingClientRect();

        // offsetX = e.clientX - rect.left; // Offset relative to element's own viewport position
        // offsetY = e.clientY - rect.top;
        
        // Calculate offset from mouse pointer to where style.left/top are calculated from
        // (i.e. relative to pdfViewerElement's padding edge)
        offsetX = e.clientX - (rect.left - viewerRect.left + pdfViewerElement.scrollLeft);
        offsetY = e.clientY - (rect.top - viewerRect.top + pdfViewerElement.scrollTop);


        // console.log("Mousedown - offsetX:", offsetX, "offsetY:", offsetY);
        // console.log("Mousedown - clientX:", e.clientX, "clientY:", e.clientY);
        // console.log("Mousedown - draggedElement.style.left:", parseFloat(draggedElement.style.left), "draggedElement.style.top:", parseFloat(draggedElement.style.top));
        // console.log("Mousedown - rect.left:", rect.left, "rect.top:", rect.top);
        // console.log("Mousedown - viewerRect.left:", viewerRect.left, "viewerRect.top:", viewerRect.top);


      });

      pdfViewerElement.appendChild(textAnnotationElement);
      textAnnotationElement.focus();

      // Reset mode after adding one text box
      isAddTextMode = false;
      addTextButtonElement.style.backgroundColor = '#555';
      addTextButtonElement.textContent = 'Add Text';
      pdfViewerElement.style.cursor = 'default';
    }
  });

  // Helper function to determine page number from canvas (simplified)
  // This would need to be more robust in a real application, perhaps by storing page info on canvas elements
  // function getPageNumFromCanvas(canvasElement) {
  //   const canvases = Array.from(pdfViewerElement.getElementsByTagName('canvas'));
  //   return canvases.indexOf(canvasElement) + 1; 
  // }

  // Global mousemove and mouseup listeners for dragging
  document.addEventListener('mousemove', function(e) {
    if (!isDragging || !draggedElement) return;

    const viewerRect = pdfViewerElement.getBoundingClientRect();
    
    // Calculate new visual position relative to pdfViewerElement
    let newVisualX = e.clientX - viewerRect.left - offsetX + pdfViewerElement.scrollLeft;
    let newVisualY = e.clientY - viewerRect.top - offsetY + pdfViewerElement.scrollTop;

    // Constrain to pdfViewerElement boundaries (optional, but good practice)
    // newVisualX = Math.max(0, Math.min(newVisualX, pdfViewerElement.scrollWidth - draggedElement.offsetWidth));
    // newVisualY = Math.max(0, Math.min(newVisualY, pdfViewerElement.scrollHeight - draggedElement.offsetHeight));

    draggedElement.style.left = newVisualX + 'px';
    draggedElement.style.top = newVisualY + 'px';
  });

  document.addEventListener('mouseup', function(e) {
    if (!isDragging || !draggedElement) return;

    const annotation = annotations.find(anno => anno.id === currentDraggedAnnotationId);
    if (annotation) {
      const allCanvases = Array.from(pdfViewerElement.getElementsByTagName('canvas'));
      const targetCanvas = allCanvases[annotation.pageNum - 1]; // pageNum is 1-based

      if (targetCanvas) {
        const canvasRect = targetCanvas.getBoundingClientRect();
        const viewerRect = pdfViewerElement.getBoundingClientRect(); // pdfViewerElement's viewport rect

        // The draggedElement.style.left/top are relative to pdfViewerElement's padding edge.
        // We need to find the position of the dragged element's top-left corner
        // relative to the targetCanvas's top-left corner.
        
        // Calculate position of draggedElement relative to viewport
        const draggedRect = draggedElement.getBoundingClientRect();

        // Calculate new canvas-relative X and Y
        // newCanvasX = draggedRect.left - canvasRect.left;
        // newCanvasY = draggedRect.top - canvasRect.top;
        
        // Alternative calculation using style.left/top which are relative to pdfViewerElement
        // style.left is relative to pdfViewerElement's padding edge.
        // canvasRect.left is relative to viewport. viewerRect.left is relative to viewport.
        // So, (canvasRect.left - viewerRect.left) is the offset of canvas from viewer's padding edge (ignoring viewer scroll).
        // Add viewer scroll to account for it.
        const canvasOffsetXInViewer = (canvasRect.left - viewerRect.left) + pdfViewerElement.scrollLeft;
        const canvasOffsetYInViewer = (canvasRect.top - viewerRect.top) + pdfViewerElement.scrollTop;

        annotation.x = parseFloat(draggedElement.style.left) - canvasOffsetXInViewer;
        annotation.y = parseFloat(draggedElement.style.top) - canvasOffsetYInViewer;
        
        // console.log("Updated annotation coords:", annotation.x, annotation.y, "for page", annotation.pageNum);
        // console.log("Dragged styleLeft:", draggedElement.style.left, "styleTop:", draggedElement.style.top);
        // console.log("Canvas offset in viewer:", canvasOffsetXInViewer, canvasOffsetYInViewer);
        // console.log("All annotations:", annotations);

      } else {
        console.error("Target canvas not found for page:", annotation.pageNum);
      }
    } else {
        console.error("Dragged annotation not found in array:", currentDraggedAnnotationId);
    }

    isDragging = false;
    draggedElement = null;
    offsetX = 0;
    offsetY = 0;
    currentDraggedAnnotationId = null;
  });

  // savePdfButtonElement listener is REMOVED as per instructions.
  // The button remains in HTML for now. A new listener will be added later.
  savePdfButtonElement.addEventListener('click', async function() {
    if (!originalPdfBytes) {
      alert("Please load a PDF file first.");
      return;
    }

    if (annotations.length === 0) {
      alert("No annotations to save. Saving the original PDF.");
      // Or, simply proceed to save the original if that's desired.
    }

    try {
      const pdfDoc = await PDFDocument.load(originalPdfBytes);
      const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
      const pages = pdfDoc.getPages();

      annotations.forEach(annotation => {
        const page = pages[annotation.pageNum - 1]; // pageNum is 1-based
        if (!page) return; // Skip if page not found (should not happen)

        if (annotation.type === 'text') {
          const fontSize = 12; // Default font size for text
          const pdfLibY = page.getHeight() - annotation.y - fontSize; // Y from bottom-left
          page.drawText(annotation.text || '', {
            x: annotation.x,
            y: pdfLibY,
            font: font,
            size: fontSize,
            color: rgb(0, 0, 0), // Black
          });
        } else if (annotation.type === 'comment') { // 4. Saving Comments
          const commentMarkerRadius = 3; // Small circle radius in PDF units
          const commentFontSize = 10;
          const commentColor = rgb(0.3, 0.3, 0.3); // Dark gray for comment text
          const markerY = page.getHeight() - annotation.y; // annotation.y is from top-left of canvas for marker pos

          // Draw a small circle marker
          page.drawCircle({
            x: annotation.x, // annotation.x is from left of canvas for marker pos
            y: markerY,
            size: commentMarkerRadius,
            color: rgb(1, 0.27, 0), // Orangey-Red, matching visual marker
          });
          
          // Place comment text slightly to the right and below the marker's center
          const textX = annotation.x + (commentMarkerRadius * 2) + 2;
          const textY = markerY - commentFontSize - 1; // Adjust Y to be below marker
          page.drawText(annotation.text || '', {
            x: textX,
            y: textY,
            font: font,
            size: commentFontSize,
            color: commentColor,
          });
        }
      });

      const pdfBytes = await pdfDoc.save();
      const blob = new Blob([pdfBytes], { type: 'application/pdf' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'annotated_pdf.pdf';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(link.href);
      alert('PDF saved successfully with annotations!');

    } catch (e) {
      console.error('Error saving PDF with annotations:', e);
      alert('Failed to save PDF with annotations. See console for details.');
    }
  });


  pdfFileElement.addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (file && file.type === 'application/pdf') {
      const fileReader = new FileReader();
      fileReader.onload = function(loadEvent) { // Changed to access event.target.result
        originalPdfBytes = loadEvent.target.result;
        const typedarray = new Uint8Array(originalPdfBytes);

        pdfjsLib.getDocument({data: typedarray}).promise.then(function(pdf) {
          console.log('PDF loaded');
          
          // 5. Clearing Visual Markers
          const oldCommentMarkers = pdfViewerElement.querySelectorAll('.comment-marker');
          oldCommentMarkers.forEach(marker => marker.remove());

          pdfViewerElement.innerHTML = ''; // Clear previous PDF canvases and textareas
          annotations = []; // Clear existing annotation data (text and comments)

          for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
            pdf.getPage(pageNum).then(function(pageInstance) { // Renamed 'page' to 'pageInstance'
              console.log('Page loaded: ' + pageNum);
              
              // const scale = 1.5; // Already defined as PDF_JS_SCALE
              const viewport = pageInstance.getViewport({scale: PDF_JS_SCALE});

              const canvas = document.createElement('canvas');
              const context = canvas.getContext('2d');
              canvas.height = viewport.height;
              canvas.width = viewport.width;
              
              pdfViewerElement.appendChild(canvas);

              const renderContext = {
                canvasContext: context,
                viewport: viewport
              };
              pageInstance.render(renderContext).promise.then(function() {
                console.log('Page rendered: ' + pageNum);
              }).catch(function(renderError) {
                console.error('Error rendering page ' + pageNum + ':', renderError);
              });
            }).catch(function(pageError){
              console.error('Error loading page ' + pageNum + ':', pageError);
            });
          }
        }).catch(function(pdfError) {
          console.error('Error loading PDF:', pdfError);
          originalPdfBytes = null; // Clear if PDF loading fails
          pdfViewerElement.innerHTML = '<p>Error loading PDF. Please ensure it is a valid PDF file.</p>';
        });
      };
      fileReader.onerror = function(error) {
          console.error('FileReader error:', error);
          originalPdfBytes = null; // Clear on error
          pdfViewerElement.innerHTML = '<p>Error reading file.</p>';
      };
      fileReader.readAsArrayBuffer(file);
    } else {
      pdfViewerElement.innerHTML = '<p>Please select a PDF file.</p>';
      console.log('No file selected or not a PDF.');
    }
  });
</script>
</body>
</html>
